<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Field Cam</title>
    
    <!-- Styles & Fonts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Libraries -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Exif-JS for Metadata Extraction -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <!-- HEIC to JPEG Converter -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; background-color: #f1f5f9; }
        .tab-content { display: none; height: 100%; overflow-y: auto; }
        .tab-content.active { display: block; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        #map-container { height: 100%; width: 100%; z-index: 1; }
        .fade-in { animation: fadeIn 0.2s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        canvas { touch-action: none; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body class="text-slate-800 h-[100dvh] flex flex-col overflow-hidden">

    <!-- HEADER -->
    <header class="bg-white shadow-sm z-30 px-4 py-3 flex justify-between items-center border-b border-slate-200 flex-none">
        <div class="flex flex-col">
            <div>
                <h1 class="text-lg font-bold text-slate-800 tracking-tight flex items-center gap-2 leading-none">
                    <i data-lucide="camera" class="w-5 h-5 text-blue-600"></i> Field Cam
                </h1>
                <p class="text-[10px] text-slate-400 font-medium ml-7">by Mario LoCoco</p>
            </div>
            <div onclick="window.app.toggleSettings()" class="text-xs text-slate-500 font-medium cursor-pointer flex items-center gap-1 hover:text-blue-600 transition mt-1">
                <span id="header-project-name">Select Project</span>
                <i data-lucide="chevron-down" class="w-3 h-3"></i>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div id="outbox-badge" class="hidden flex items-center gap-1 px-2 py-1 bg-orange-100 text-orange-700 rounded-full text-[10px] font-bold animate-pulse cursor-pointer" onclick="window.app.syncOutbox()">
                <i data-lucide="upload-cloud" class="w-3 h-3"></i> <span id="outbox-count">0</span>
            </div>
            <div id="status-indicator" class="w-3 h-3 rounded-full bg-slate-300 ring-2 ring-white shadow-sm transition-colors duration-300"></div>
            <button onclick="window.app.toggleSettings()" class="p-2 text-slate-400 hover:text-blue-600 transition bg-slate-50 rounded-full">
                <i data-lucide="settings" class="w-5 h-5"></i>
            </button>
        </div>
    </header>

    <!-- MAIN CONTENT AREA -->
    <main class="flex-1 relative overflow-hidden bg-slate-100">

        <!-- TAB 1: INSPECT -->
        <div id="tab-inspect" class="tab-content active p-4 space-y-4">
            
            <!-- Sensor Dashboard -->
            <div class="grid grid-cols-3 gap-3">
                <div class="bg-white rounded-xl p-3 shadow-sm border border-slate-200 flex flex-col items-center justify-center text-center">
                    <div class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-1">GPS</div>
                    <div id="gps-val" class="text-xs font-mono font-bold text-slate-600 truncate w-full">Waiting...</div>
                </div>
                <div onclick="window.app.requestCompass()" class="bg-white rounded-xl p-3 shadow-sm border border-slate-200 flex flex-col items-center justify-center text-center cursor-pointer hover:bg-slate-50 transition active:scale-95">
                    <div class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-1">Heading</div>
                    <div class="flex items-center gap-1 justify-center w-full">
                        <svg id="compass-icon" class="w-4 h-4 transition-transform duration-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10" class="text-slate-200 stroke-slate-200" />
                            <path d="M12 2L15 12H9L12 2Z" fill="#ef4444" stroke="none" />
                            <path d="M12 22L9 12H15L12 22Z" fill="#94a3b8" stroke="none" />
                        </svg>
                        <span id="compass-val" class="text-xs font-mono font-bold text-slate-600">Off</span>
                    </div>
                </div>
                <div class="bg-white rounded-xl p-3 shadow-sm border border-slate-200 flex flex-col items-center justify-center text-center">
                    <div class="text-[10px] font-bold text-slate-400 uppercase tracking-wider mb-1">Wx</div>
                    <div id="wx-val" class="text-xs font-medium text-slate-600 truncate w-full">--</div>
                </div>
            </div>

            <!-- Main Actions -->
            <div class="bg-white rounded-2xl shadow-sm border border-slate-200 p-4">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-sm font-bold text-slate-700">Capture</h2>
                    <div class="flex items-center gap-2">
                         <label class="flex items-center gap-2 text-xs text-slate-500 cursor-pointer select-none">
                            <input type="checkbox" id="burn-toggle" checked class="w-3.5 h-3.5 text-blue-600 rounded focus:ring-blue-500 border-gray-300">
                            <span>Overlay Data</span>
                        </label>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3">
                    <!-- 1. Live Photo Container -->
                    <div class="flex flex-col gap-2">
                        <label class="cursor-pointer group relative flex flex-col items-center justify-center bg-blue-50 hover:bg-blue-100 rounded-xl p-4 border-2 border-dashed border-blue-200 transition active:scale-95 h-28">
                            <div class="w-10 h-10 bg-blue-600 rounded-full flex items-center justify-center shadow-lg text-white mb-2 group-hover:scale-110 transition-transform">
                                <i data-lucide="camera" class="w-5 h-5"></i>
                            </div>
                            <span class="text-xs font-bold text-blue-900">Live Photo</span>
                            <input type="file" id="camera-input" accept="image/*" capture="environment" class="hidden">
                        </label>
                        <button id="series-btn" onclick="window.app.toggleSeriesMode()" class="w-full py-1.5 rounded-lg text-[10px] font-bold border flex items-center justify-center gap-1 transition bg-white text-slate-500 border-slate-200 hover:bg-slate-50">
                            <i data-lucide="layers" class="w-3 h-3"></i> <span id="series-text">Series Mode</span>
                        </button>
                    </div>

                    <!-- 2. Gallery Upload -->
                    <label class="cursor-pointer group relative flex flex-col items-center justify-center bg-indigo-50 hover:bg-indigo-100 rounded-xl p-4 border-2 border-dashed border-indigo-200 transition active:scale-95 h-28">
                        <div class="w-10 h-10 bg-indigo-600 rounded-full flex items-center justify-center shadow-lg text-white mb-2 group-hover:scale-110 transition-transform">
                            <i data-lucide="image" class="w-5 h-5"></i>
                        </div>
                        <span class="text-xs font-bold text-indigo-900">Gallery</span>
                        <input type="file" id="gallery-input" accept="image/*" class="hidden">
                    </label>

                    <!-- 3. Sketch -->
                    <button onclick="window.app.openSketch()" class="cursor-pointer group relative flex flex-col items-center justify-center bg-purple-50 hover:bg-purple-100 rounded-xl p-4 border-2 border-dashed border-purple-200 transition active:scale-95 h-28">
                        <div class="w-10 h-10 bg-purple-600 rounded-full flex items-center justify-center shadow-lg text-white mb-2 group-hover:scale-110 transition-transform">
                            <i data-lucide="pen-tool" class="w-5 h-5"></i>
                        </div>
                        <span class="text-xs font-bold text-purple-900">Sketch</span>
                    </button>

                    <!-- 4. Notes (Triggers Modal) -->
                    <button onclick="window.app.openNotes()" class="cursor-pointer group relative flex flex-col items-center justify-center bg-emerald-50 hover:bg-emerald-100 rounded-xl p-4 border-2 border-dashed border-emerald-200 transition active:scale-95 h-28">
                        <div class="w-10 h-10 bg-emerald-600 rounded-full flex items-center justify-center shadow-lg text-white mb-2 group-hover:scale-110 transition-transform">
                            <i data-lucide="file-text" class="w-5 h-5"></i>
                        </div>
                        <span class="text-xs font-bold text-emerald-900">Notes</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- TAB 2: REPORT -->
        <div id="tab-report" class="tab-content h-full bg-white">
            <div class="flex flex-col h-full">
                <!-- Header with Report Button -->
                <div class="p-4 border-b border-slate-200 flex justify-between items-center bg-slate-50 flex-none">
                    <h2 class="font-bold text-slate-800">Project Log</h2>
                    <button onclick="window.app.genPDF()" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 rounded-lg text-xs font-bold shadow flex items-center gap-1 active:scale-95 transition">
                        <i data-lucide="file-text" class="w-3 h-3"></i> Generate Report
                    </button>
                </div>

                <!-- Toolbar -->
                <div class="p-3 border-b border-slate-200 flex gap-2 overflow-x-auto no-scrollbar bg-white sticky top-0 z-10 flex-none">
                    <div class="flex-1 relative">
                        <i data-lucide="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400"></i>
                        <input type="text" id="search-input" onkeyup="window.app.filterFeed()" placeholder="Search..." class="w-full pl-9 pr-3 py-2 bg-slate-100 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                    </div>
                    <div class="flex bg-slate-100 rounded-lg p-1">
                        <button onclick="window.app.setFilter('all')" id="filter-all" class="px-3 py-1.5 rounded text-xs font-bold transition bg-white shadow text-slate-800">All</button>
                        <button onclick="window.app.setFilter('photo')" id="filter-photo" class="px-3 py-1.5 rounded text-xs font-bold transition text-slate-500 hover:text-slate-700">Photos</button>
                        <button onclick="window.app.setFilter('sketch')" id="filter-sketch" class="px-3 py-1.5 rounded text-xs font-bold transition text-slate-500 hover:text-slate-700">Sketches</button>
                        <button onclick="window.app.setFilter('note')" id="filter-note" class="px-3 py-1.5 rounded text-xs font-bold transition text-slate-500 hover:text-slate-700">Notes</button>
                    </div>
                </div>

                <!-- Feed -->
                <div id="report-feed" class="flex-1 overflow-y-auto p-4 space-y-4 bg-slate-50 pb-20">
                    <!-- Dynamic Content -->
                </div>

                <!-- Floating Action for Export -->
                <div class="absolute bottom-4 right-4 z-20">
                    <button onclick="document.getElementById('export-modal').classList.remove('hidden')" class="bg-blue-600 hover:bg-blue-700 text-white rounded-full p-3 shadow-lg flex items-center gap-2 pr-5 transition transform active:scale-95">
                        <i data-lucide="download" class="w-5 h-5"></i>
                        <span class="text-sm font-bold">Export</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- TAB 3: MAP -->
        <div id="tab-map" class="tab-content h-full relative">
            <div id="map-container" class="bg-slate-200"></div>
            <button onclick="window.app.centerMap()" class="absolute bottom-6 right-4 bg-white p-2 rounded-lg shadow-md z-[400] text-slate-700 hover:text-blue-600">
                <i data-lucide="crosshair" class="w-6 h-6"></i>
            </button>
        </div>

        <!-- TAB 4: FILES -->
        <div id="tab-files" class="tab-content p-4">
            <div class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex flex-col h-full">
                <div class="p-3 border-b border-slate-200 flex justify-between items-center bg-slate-50">
                    <h3 class="text-sm font-bold text-slate-700">Raw Storage</h3>
                    <div class="flex gap-2">
                        <button onclick="window.app.fileBrowserUp()" class="p-1.5 hover:bg-slate-200 rounded text-slate-600"><i data-lucide="arrow-up" class="w-4 h-4"></i></button>
                        <button onclick="window.app.refreshFiles()" class="p-1.5 hover:bg-slate-200 rounded text-slate-600"><i data-lucide="refresh-cw" class="w-4 h-4"></i></button>
                    </div>
                </div>
                <div class="px-3 py-1 bg-slate-100 text-[10px] font-mono text-slate-500 truncate border-b border-slate-200" id="browser-path">/</div>
                <div id="file-grid" class="flex-1 overflow-y-auto p-4 grid grid-cols-3 sm:grid-cols-4 gap-3 content-start"></div>
            </div>
        </div>

    </main>

    <!-- BOTTOM NAVIGATION -->
    <nav class="bg-white border-t border-slate-200 flex justify-around items-center h-[70px] pb-safe z-30 flex-none">
        <button onclick="window.app.switchTab('inspect')" id="nav-inspect" class="nav-item active flex flex-col items-center justify-center w-full h-full text-blue-600 transition group">
            <i data-lucide="camera" class="w-6 h-6 mb-1 group-hover:scale-110 transition-transform"></i>
            <span class="text-[10px] font-bold">Inspect</span>
        </button>
        <button onclick="window.app.switchTab('report')" id="nav-report" class="nav-item flex flex-col items-center justify-center w-full h-full text-slate-400 hover:text-blue-600 transition group">
            <i data-lucide="clipboard-list" class="w-6 h-6 mb-1 group-hover:scale-110 transition-transform"></i>
            <span class="text-[10px] font-bold">Log</span>
        </button>
        <button onclick="window.app.switchTab('map')" id="nav-map" class="nav-item flex flex-col items-center justify-center w-full h-full text-slate-400 hover:text-blue-600 transition group">
            <i data-lucide="map" class="w-6 h-6 mb-1 group-hover:scale-110 transition-transform"></i>
            <span class="text-[10px] font-bold">Map</span>
        </button>
        <button onclick="window.app.switchTab('files')" id="nav-files" class="nav-item flex flex-col items-center justify-center w-full h-full text-slate-400 hover:text-blue-600 transition group">
            <i data-lucide="hard-drive" class="w-6 h-6 mb-1 group-hover:scale-110 transition-transform"></i>
            <span class="text-[10px] font-bold">Files</span>
        </button>
    </nav>

    <!-- MODAL: NOTES -->
    <div id="modal-notes" class="fixed inset-0 z-50 bg-black/90 hidden flex flex-col justify-end sm:justify-center p-0 sm:p-4 fade-in">
        <div class="bg-white w-full max-w-md mx-auto rounded-t-2xl sm:rounded-2xl overflow-hidden flex flex-col max-h-[90vh]">
            <div class="p-4 border-b border-slate-200 bg-slate-50 flex justify-between items-center">
                <div class="flex items-center gap-2 text-slate-700 font-bold">
                    <i data-lucide="file-text" class="w-5 h-5 text-emerald-600"></i> Field Observation
                </div>
                <button onclick="window.app.closeNotes()" class="p-1 rounded hover:bg-slate-200 text-slate-500"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <div class="p-5 flex-1 overflow-y-auto space-y-4">
                <div>
                    <label class="text-[10px] font-bold text-slate-500 uppercase">Title / Location</label>
                    <input type="text" id="note-title" placeholder="e.g. North Abutment" class="w-full border border-slate-300 rounded-lg p-3 text-sm focus:ring-2 focus:ring-emerald-500 outline-none mt-1">
                </div>
                <div>
                    <label class="text-[10px] font-bold text-slate-500 uppercase">Description</label>
                    <textarea id="note-text" placeholder="Enter observation details..." class="w-full border border-slate-300 rounded-lg p-3 text-sm h-32 resize-none focus:ring-2 focus:ring-emerald-500 outline-none mt-1"></textarea>
                </div>
            </div>
            <div class="p-4 border-t border-slate-200 bg-slate-50 flex gap-3 flex-none pb-safe">
                <button onclick="window.app.closeNotes()" class="flex-1 py-3 bg-white border border-slate-300 text-slate-700 font-bold rounded-xl text-sm hover:bg-slate-50">Cancel</button>
                <button onclick="window.app.saveNote()" class="flex-1 py-3 bg-emerald-600 text-white font-bold rounded-xl text-sm shadow hover:bg-emerald-700">Save Note</button>
            </div>
        </div>
    </div>

    <!-- MODAL: CAPTION / EDIT -->
    <div id="modal-caption" class="fixed inset-0 z-50 bg-black/90 hidden flex flex-col justify-end sm:justify-center p-0 sm:p-4 fade-in">
        <div class="bg-white w-full max-w-md mx-auto rounded-t-2xl sm:rounded-2xl overflow-hidden flex flex-col max-h-[90vh]">
            <div class="relative bg-slate-100 flex-none h-64 flex items-center justify-center border-b border-slate-200">
                <img id="modal-img-preview" class="max-h-full max-w-full object-contain">
                <div id="exif-badge" class="hidden absolute top-2 right-2 bg-black/60 text-white text-[10px] px-2 py-1 rounded-full backdrop-blur-md border border-white/20 flex items-center gap-1">
                    <i data-lucide="map-pin" class="w-3 h-3 text-green-400"></i> Using EXIF Data
                </div>
                <button onclick="window.app.annotateImage()" class="absolute bottom-2 right-2 bg-white/90 p-2 rounded-lg shadow text-xs font-bold flex items-center gap-1 hover:bg-white text-slate-700">
                    <i data-lucide="pen-tool" class="w-3 h-3"></i> Draw
                </button>
            </div>
            <div class="p-5 flex-1 overflow-y-auto">
                <h3 class="text-sm font-bold text-slate-800 uppercase mb-3 flex justify-between">
                    <span id="modal-title-text">Image Details</span>
                </h3>
                <div class="space-y-3">
                    <div>
                        <label class="text-[10px] font-bold text-slate-500 uppercase">Title / Location</label>
                        <input type="text" id="cap-title" class="w-full border border-slate-300 rounded-lg p-2.5 text-sm focus:ring-2 focus:ring-blue-500 outline-none">
                    </div>
                    <div>
                        <label class="text-[10px] font-bold text-slate-500 uppercase">Description</label>
                        <textarea id="cap-desc" class="w-full border border-slate-300 rounded-lg p-2.5 text-sm h-24 resize-none focus:ring-2 focus:ring-blue-500 outline-none"></textarea>
                    </div>
                </div>
            </div>
            <div class="p-4 border-t border-slate-200 bg-slate-50 flex gap-3 flex-none pb-safe">
                <button onclick="window.app.closeCaptionModal()" class="flex-1 py-3 bg-white border border-slate-300 text-slate-700 font-bold rounded-xl text-sm hover:bg-slate-50">Cancel</button>
                <button onclick="window.app.confirmUpload()" id="btn-save-upload" class="flex-1 py-3 bg-blue-600 text-white font-bold rounded-xl text-sm shadow hover:bg-blue-700">Save</button>
            </div>
        </div>
    </div>

    <!-- MODAL: SKETCH -->
    <div id="modal-sketch" class="fixed inset-0 z-[60] bg-white hidden flex flex-col fade-in">
        <div class="flex-none p-3 border-b border-slate-200 flex justify-between items-center bg-slate-50">
            <button onclick="window.app.closeSketch()" class="text-slate-500 font-medium text-sm">Cancel</button>
            <div class="flex items-center gap-3">
                <input type="color" id="sketch-color" value="#ef4444" class="w-8 h-8 rounded-full overflow-hidden border-0 p-0 cursor-pointer">
                <input type="range" id="sketch-size" min="2" max="15" value="4" class="w-24 accent-blue-600">
                <div class="w-px h-6 bg-slate-300 mx-1"></div>
                <button onclick="window.app.toggleEraser()" id="btn-eraser" class="p-1.5 rounded-lg hover:bg-slate-200 text-slate-500 transition" title="Eraser"><i data-lucide="eraser" class="w-5 h-5"></i></button>
                <button onclick="window.app.undoSketch()" class="p-1.5 rounded-lg hover:bg-slate-200 text-slate-500 transition" title="Undo"><i data-lucide="rotate-ccw" class="w-5 h-5"></i></button>
            </div>
            <button onclick="window.app.saveSketch()" class="text-blue-600 font-bold text-sm">Done</button>
        </div>
        <div class="flex-1 relative bg-white cursor-crosshair touch-none overflow-hidden" id="sketch-wrapper">
            <canvas id="sketch-canvas" class="block"></canvas>
        </div>
        <div class="flex-none p-2 border-t border-slate-200 flex justify-center pb-safe">
            <button onclick="window.app.clearSketch()" class="text-xs text-red-500 font-bold px-4 py-2 hover:bg-red-50 rounded-lg">Clear Canvas</button>
        </div>
    </div>

    <!-- MODAL: EXPORT -->
    <div id="export-modal" class="fixed inset-0 z-50 bg-black/80 hidden flex items-center justify-center p-4 fade-in">
        <div class="bg-white rounded-2xl w-full max-w-sm overflow-hidden shadow-2xl">
            <div class="p-5 border-b border-slate-100 flex justify-between items-center">
                <h3 class="font-bold text-slate-800">Export Options</h3>
                <button onclick="document.getElementById('export-modal').classList.add('hidden')" class="text-slate-400 hover:text-slate-600"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <div class="p-5 space-y-3">
                <button onclick="window.app.genPDF()" class="w-full flex items-center p-3 rounded-xl border border-slate-200 hover:bg-red-50 hover:border-red-200 transition group">
                    <div class="w-10 h-10 rounded-full bg-red-100 text-red-600 flex items-center justify-center mr-3 group-hover:bg-red-200"><i data-lucide="file-text" class="w-5 h-5"></i></div>
                    <div class="text-left"><div class="font-bold text-slate-700 text-sm">PDF Report</div><div class="text-[10px] text-slate-500">Compiles photos & notes</div></div>
                </button>
                <button onclick="window.app.genCSV()" class="w-full flex items-center p-3 rounded-xl border border-slate-200 hover:bg-green-50 hover:border-green-200 transition group">
                    <div class="w-10 h-10 rounded-full bg-green-100 text-green-600 flex items-center justify-center mr-3 group-hover:bg-green-200"><i data-lucide="table" class="w-5 h-5"></i></div>
                    <div class="text-left"><div class="font-bold text-slate-700 text-sm">CSV Data</div><div class="text-[10px] text-slate-500">Spreadsheet compatible</div></div>
                </button>
                <button onclick="window.app.genZip()" class="w-full flex items-center p-3 rounded-xl border border-slate-200 hover:bg-blue-50 hover:border-blue-200 transition group">
                    <div class="w-10 h-10 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center mr-3 group-hover:bg-blue-200"><i data-lucide="archive" class="w-5 h-5"></i></div>
                    <div class="text-left"><div class="font-bold text-slate-700 text-sm">Photos ZIP</div><div class="text-[10px] text-slate-500">Full resolution archive</div></div>
                </button>
                <button onclick="window.app.genRawZip()" class="w-full flex items-center p-3 rounded-xl border border-slate-200 hover:bg-orange-50 hover:border-orange-200 transition group">
                    <div class="w-10 h-10 rounded-full bg-orange-100 text-orange-600 flex items-center justify-center mr-3 group-hover:bg-orange-200"><i data-lucide="camera-off" class="w-5 h-5"></i></div>
                    <div class="text-left"><div class="font-bold text-slate-700 text-sm">Raw Images ZIP</div><div class="text-[10px] text-slate-500">Originals without overlay</div></div>
                </button>
            </div>
        </div>
    </div>

    <!-- MODAL: SETTINGS -->
    <div id="settings-modal" class="fixed inset-0 z-50 bg-black/80 hidden flex items-center justify-center p-4 fade-in">
        <div class="bg-white rounded-2xl w-full max-w-xs p-6 shadow-2xl">
            <h3 class="text-lg font-bold text-slate-800 mb-4">Project Settings</h3>
            
            <div class="flex items-center justify-between mb-4">
                <span class="text-xs font-bold text-slate-500 uppercase">Connection</span>
                <button id="offline-toggle-btn" onclick="window.app.toggleForceOffline()" class="text-xs font-bold px-3 py-1 rounded bg-green-100 text-green-700 border border-green-200 transition">
                    Online
                </button>
            </div>
            
            <label class="text-xs font-bold text-slate-500 uppercase mb-1 block">Active Project</label>
            <select id="project-select" onchange="window.app.switchProject(this.value)" class="w-full border border-slate-300 rounded-lg p-2.5 text-sm mb-1 bg-white"></select>
            
            <div class="text-right mb-3">
                <button onclick="window.app.deleteCurrentProject()" class="text-[10px] font-bold text-red-500 hover:text-red-700 underline">Delete Project & Data</button>
            </div>

            <div class="border-t border-slate-200 my-4"></div>
            
            <label class="text-xs font-bold text-slate-500 uppercase mb-1 block">New Project</label>
            <div class="flex gap-2 mb-4">
                <input type="text" id="new-proj-name" placeholder="Name..." class="flex-1 border border-slate-300 rounded-lg p-2 text-sm">
                <button onclick="window.app.createProject()" class="bg-blue-600 text-white rounded-lg px-4 font-bold text-sm">Add</button>
            </div>
            
            <button onclick="window.app.toggleSettings()" class="w-full py-3 bg-slate-100 text-slate-700 font-bold rounded-xl text-sm hover:bg-slate-200">Close</button>
        </div>
    </div>

    <!-- MODAL: IMAGE DETAIL -->
    <div id="detail-modal" class="fixed inset-0 z-[60] bg-black hidden flex flex-col justify-center fade-in">
        <div class="absolute top-0 w-full p-4 bg-gradient-to-b from-black/80 to-transparent z-10 flex justify-between items-start text-white">
            <div>
                <h3 class="font-bold text-lg" id="det-project"></h3>
                <div class="text-xs opacity-75 font-mono" id="det-id"></div>
            </div>
            <button onclick="document.getElementById('detail-modal').classList.add('hidden')" class="bg-white/10 p-2 rounded-full backdrop-blur-sm"><i data-lucide="x" class="w-6 h-6"></i></button>
        </div>
        
        <div class="flex-1 flex items-center justify-center overflow-hidden">
            <img id="det-img" class="max-w-full max-h-full object-contain">
        </div>
        
        <div class="bg-slate-900 text-slate-300 p-5 pb-safe space-y-3">
            <p id="det-caption" class="text-white font-bold text-base"></p>
            <div class="grid grid-cols-2 gap-4 text-xs font-mono opacity-80">
                <div>DATE: <span id="det-date" class="text-blue-400"></span></div>
                <div>GPS: <a id="det-gps" target="_blank" class="text-blue-400 hover:underline"></a></div>
            </div>
            <div class="flex gap-3 pt-2">
                <button id="det-dl-btn" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white py-2 rounded font-bold text-xs">Download Overlay</button>
                <button id="det-raw-btn" class="flex-1 bg-slate-700 hover:bg-slate-600 text-white py-2 rounded font-bold text-xs hidden">Download Raw</button>
            </div>
        </div>
    </div>

    <!-- TOAST & LOADER -->
    <div id="toast" class="fixed bottom-24 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-5 py-2.5 rounded-full shadow-xl text-sm font-bold opacity-0 transition-opacity duration-300 pointer-events-none z-[70] flex items-center gap-2">
        <i data-lucide="check-circle" class="w-4 h-4 text-green-400"></i> <span id="toast-msg">Action</span>
    </div>
    
    <div id="loader" class="fixed inset-0 z-[80] bg-white/90 hidden flex flex-col items-center justify-center fade-in">
        <div class="w-12 h-12 border-4 border-slate-200 border-t-blue-600 rounded-full animate-spin mb-3"></div>
        <div id="loader-text" class="text-slate-600 font-bold animate-pulse">Processing...</div>
    </div>

    <!-- FIREBASE & APP LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, query, where, onSnapshot, deleteDoc, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, listAll, deleteObject } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // CONFIG
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'field-notes-v2';
        const fbConfig = (typeof __firebase_config !== 'undefined') ? JSON.parse(__firebase_config) : { apiKey: "AIzaSyD2jsJTjSlWf3SINS3u4fz3Lu5IYbI6N94", authDomain: "field-cam.firebaseapp.com", projectId: "field-cam", storageBucket: "field-cam.firebasestorage.app", messagingSenderId: "952385597528", appId: "1:952385597528:web:3a5b2011a4cc2b29e41a2d" };

        // APP STATE
        const state = {
            db: null, storage: null, auth: null, user: null,
            project: localStorage.getItem('fp_project') || "Project-Alpha",
            projects: new Set(JSON.parse(localStorage.getItem('fp_projects') || '["Project-Alpha"]')),
            location: null, weather: { temp: '', desc: '' }, heading: null,
            filter: 'all', path: `artifacts/${appId}/public/data/files`,
            items: [], seriesMode: false, queue: [],
            pendingBlob: null, pendingId: null, editMode: false, pendingType: 'photo',
            tempMeta: null, // Holds EXIF data temporarily
            online: navigator.onLine, // Connection state
            forcedOffline: false, // User override
            batchMode: false, // Flag for batch upload workflow
            excludedReportItems: new Set() // IDs of items to exclude from report
        };

        // UTILS
        const $ = (id) => document.getElementById(id);
        const showToast = (msg) => {
            $('toast-msg').innerText = msg; $('toast').classList.remove('opacity-0');
            setTimeout(() => $('toast').classList.add('opacity-0'), 2500);
        };
        const toggleLoader = (show, txt="Loading...") => {
            if(show) { $('loader-text').innerText = txt; $('loader').classList.remove('hidden'); }
            else $('loader').classList.add('hidden');
        };
        const formatDate = (ts) => new Date(ts).toLocaleDateString() + ' ' + new Date(ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});

        // INDEXED DB HELPER FOR OFFLINE STORAGE
        class OfflineManager {
            constructor() {
                this.dbName = 'FieldNotesDB';
                this.storeName = 'pending_uploads';
                this.db = null;
                this.initDB();
            }

            initDB() {
                const req = indexedDB.open(this.dbName, 1);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if(!db.objectStoreNames.contains(this.storeName)) {
                        db.createObjectStore(this.storeName, { keyPath: 'id' });
                    }
                };
                req.onsuccess = (e) => {
                    this.db = e.target.result;
                    this.updateOutboxCount();
                };
            }

            async addToOutbox(item) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction([this.storeName], 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    store.put(item);
                    tx.oncomplete = () => {
                        this.updateOutboxCount();
                        resolve();
                    };
                    tx.onerror = (e) => reject(e);
                });
            }

            async getOutbox() {
                return new Promise((resolve) => {
                    if(!this.db) return resolve([]);
                    const tx = this.db.transaction([this.storeName], 'readonly');
                    const store = tx.objectStore(this.storeName);
                    const req = store.getAll();
                    req.onsuccess = () => resolve(req.result);
                });
            }

            async removeFromOutbox(id) {
                return new Promise((resolve) => {
                    const tx = this.db.transaction([this.storeName], 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    store.delete(id);
                    tx.oncomplete = () => {
                        this.updateOutboxCount();
                        resolve();
                    };
                });
            }

            async updateOutboxCount() {
                const items = await this.getOutbox();
                const badge = $('outbox-badge');
                if(items.length > 0) {
                    badge.classList.remove('hidden');
                    $('outbox-count').innerText = items.length;
                } else {
                    badge.classList.add('hidden');
                }
            }
        }

        // --- CORE APPLICATION ---
        class FieldApp {
            constructor() {
                this.map = null;
                this.markers = null;
                this.wbCtx = null;
                this.bgImage = null; // Store background image for clearing sketch
                this.undoStack = []; // Stack for undo feature
                this.isEraser = false; // Eraser mode toggle
                this.lastColor = '#ef4444'; // Default color
                this.offlineMgr = new OfflineManager();
                this.initFirebase();
                this.initSensors();
                this.bindEvents();
                lucide.createIcons();
                
                // Connection Listeners
                window.addEventListener('online', () => this.updateConnectionStatus(true));
                window.addEventListener('offline', () => this.updateConnectionStatus(false));
                this.updateConnectionStatus(navigator.onLine);
            }
            
            toggleForceOffline() {
                state.forcedOffline = !state.forcedOffline;
                this.updateConnectionStatus();
                
                // Update Button Visual
                const btn = $('offline-toggle-btn');
                if(state.forcedOffline) {
                    btn.innerText = "Offline (Forced)";
                    btn.className = "text-xs font-bold px-3 py-1 rounded bg-orange-100 text-orange-700 border border-orange-200 transition";
                } else {
                    btn.innerText = "Online";
                    btn.className = "text-xs font-bold px-3 py-1 rounded bg-green-100 text-green-700 border border-green-200 transition";
                }
                
                showToast(state.forcedOffline ? "Offline Mode Enabled" : "Back Online");
            }

            updateConnectionStatus() {
                // Effective status logic
                const networkOnline = navigator.onLine;
                const effectiveOnline = networkOnline && !state.forcedOffline;
                state.online = effectiveOnline;

                $('status-indicator').className = `w-3 h-3 rounded-full ring-2 ring-white shadow-sm transition-colors duration-300 ${effectiveOnline ? 'bg-green-500' : 'bg-orange-500'}`;
                
                if(effectiveOnline) this.syncOutbox();
            }

            async syncOutbox() {
                if(!state.online) return showToast("Still Offline");
                const items = await this.offlineMgr.getOutbox();
                if(items.length === 0) return;

                toggleLoader(true, `Syncing ${items.length} items...`);
                let successCount = 0;

                for(const item of items) {
                    try {
                        // Restore blob from DB (it's stored as is)
                        // If it's a note (no blob), skip upload logic
                        if(item.type === 'note') {
                            await setDoc(doc(state.db, `artifacts/${appId}/public/data/images`, item.id), item.meta);
                        } else {
                            // Ensure meta.type is present, default to 'photo' if missing in older pending items
                            item.meta.type = item.type || 'photo'; 
                            await this.uploadWorkflow(item.blob, item.meta, item.doOverlay);
                        }
                        await this.offlineMgr.removeFromOutbox(item.id);
                        successCount++;
                    } catch(e) {
                        console.error("Sync failed for item", item.id, e);
                    }
                }
                
                toggleLoader(false);
                if(successCount > 0) showToast(`Synced ${successCount} items`);
            }

            async initFirebase() {
                const app = initializeApp(fbConfig);
                state.auth = getAuth(app);
                state.db = getFirestore(app);
                state.storage = getStorage(app);

                onAuthStateChanged(state.auth, (user) => {
                    state.user = user;
                    // Status logic moved to updateConnectionStatus for better control
                    if(user) {
                        this.loadData();
                        this.refreshFiles();
                        this.syncProjectList(); // Check storage & DB for projects
                        
                        // NEW: Listen to shared project list
                        this.listenToSharedProjects();
                    }
                });

                // Auth Logic
                const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                try {
                    if (token) await signInWithCustomToken(state.auth, token);
                    else await signInAnonymously(state.auth);
                } catch(e) { console.error("Auth Fail", e); }

                this.updateProjectUI();
            }
            
            // NEW: Shared Project List Listener
            listenToSharedProjects() {
                const q = query(collection(state.db, `artifacts/${appId}/public/data/projects`), orderBy('name'));
                onSnapshot(q, (snap) => {
                    snap.forEach(d => {
                        state.projects.add(d.data().name);
                    });
                    localStorage.setItem('fp_projects', JSON.stringify(Array.from(state.projects)));
                    this.updateProjectUI(); // Refresh dropdown
                });
            }

            // --- SENSORS ---
            initSensors() {
                // GPS
                if(navigator.geolocation) {
                    navigator.geolocation.watchPosition(p => {
                        state.location = { lat: p.coords.latitude, lng: p.coords.longitude };
                        $('gps-val').innerText = `${p.coords.latitude.toFixed(5)}, ${p.coords.longitude.toFixed(5)}`;
                        $('gps-val').className = "text-xs font-mono font-bold text-green-600 truncate w-full";
                        if(!state.weather.temp) this.fetchWeather(p.coords.latitude, p.coords.longitude);
                    }, e => {
                        $('gps-val').innerText = "No Signal";
                        $('gps-val').className = "text-xs font-mono font-bold text-red-500 truncate w-full";
                    }, { enableHighAccuracy: true });
                }

                // Compass (Requires explicit permission on iOS)
                // We listen for events, but UI triggers requestCompass()
                window.addEventListener('deviceorientation', this.handleOrientation.bind(this));
            }

            async requestCompass() {
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const perm = await DeviceOrientationEvent.requestPermission();
                        if (perm === 'granted') showToast("Compass Active");
                        else showToast("Permission Denied");
                    } catch (e) { alert(e); }
                } else {
                    showToast("Compass Active");
                }
            }

            handleOrientation(e) {
                let heading = e.webkitCompassHeading || Math.abs(e.alpha - 360);
                if(heading) {
                    state.heading = heading;
                    $('compass-val').innerText = Math.round(heading) + "°";
                    $('compass-icon').style.transform = `rotate(${heading * -1}deg)`;
                }
            }

            async fetchWeather(lat, lng) {
                try {
                    const r = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&temperature_unit=fahrenheit`);
                    const d = await r.json();
                    if(d.current_weather) {
                        const code = d.current_weather.weathercode;
                        const temp = d.current_weather.temperature;
                        const desc = code === 0 ? "Clear" : code < 4 ? "Cloudy" : code < 50 ? "Fog" : "Precip";
                        state.weather = { temp: `${temp}°F`, desc };
                        $('wx-val').innerText = `${desc}, ${temp}°F`;
                    }
                } catch(e) {}
            }

            // --- UI ACTIONS ---
            switchTab(id) {
                document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
                $( `tab-${id}` ).classList.add('active');
                document.querySelectorAll('.nav-item').forEach(el => {
                    el.classList.remove('text-blue-600', 'active');
                    el.classList.add('text-slate-400');
                });
                const nav = $(`nav-${id}`);
                nav.classList.add('text-blue-600', 'active');
                nav.classList.remove('text-slate-400');

                if(id === 'map') {
                    setTimeout(() => {
                        if(!this.map) this.initMap();
                        this.map.invalidateSize();
                        this.renderMapMarkers();
                    }, 100);
                }
            }

            toggleSettings() {
                const m = $('settings-modal');
                m.classList.toggle('hidden');
                if(!m.classList.contains('hidden')) {
                    this.updateProjectUI(); // Ensure dropdown is fresh
                }
            }

            updateProjectUI() {
                // Update Header
                $('header-project-name').innerText = state.project;
                
                // Update Settings Dropdown
                const sel = $('project-select');
                if(sel) {
                    sel.innerHTML = '';
                    Array.from(state.projects).sort().forEach(p => {
                        const opt = document.createElement('option');
                        opt.value = p; opt.text = p; opt.selected = (p === state.project);
                        sel.appendChild(opt);
                    });
                }
            }

            // --- PROJECT LOGIC ---
            async createProject(nameOverride = null) {
                let n = nameOverride;
                if (!n) n = $('new-proj-name').value.trim().replace(/[^a-zA-Z0-9-_]/g, '');
                
                if(n) {
                    state.projects.add(n);
                    localStorage.setItem('fp_projects', JSON.stringify(Array.from(state.projects)));
                    
                    // SAVE TO FIRESTORE SHARED LIST
                    try {
                        const projRef = doc(state.db, `artifacts/${appId}/public/data/projects`, n);
                        await setDoc(projRef, {
                            name: n,
                            createdAt: Date.now(),
                            createdBy: state.user.uid
                        });
                    } catch(e) { console.warn("Could not sync project list to cloud", e); }

                    this.switchProject(n);
                    if(!nameOverride) $('new-proj-name').value = '';
                }
            }

            switchProject(p) {
                state.project = p;
                localStorage.setItem('fp_project', p);
                this.updateProjectUI();
                this.loadData(); // Reload data for new project
                this.toggleSettings();
                showToast(`Switched to ${p}`);
            }

            async deleteCurrentProject() {
                const p = state.project;
                if(!confirm(`⚠️ DANGER ZONE ⚠️\n\nAre you sure you want to delete project: "${p}"?\n\nThis will PERMANENTLY DELETE all photos, notes, and files associated with this project.\n\nThis action cannot be undone.`)) return;
                
                const confirmName = prompt(`To confirm deletion, please type the project name "${p}" below:`);
                if(confirmName !== p) return alert("Project name did not match. Deletion cancelled.");

                toggleLoader(true, `Deleting ${p}...`);
                this.toggleSettings(); // Close modal

                try {
                    // 1. Delete Firestore Documents (Photos)
                    const q = query(collection(state.db, `artifacts/${appId}/public/data/images`), where("projectId", "==", p));
                    const snap = await getDocs(q);
                    const docDeletes = snap.docs.map(d => deleteDoc(d.ref));
                    await Promise.all(docDeletes);

                    // 2. Delete Project Metadata Doc
                    await deleteDoc(doc(state.db, `artifacts/${appId}/public/data/projects`, p));

                    // 3. Delete Storage Files
                    const folderRef = ref(state.storage, `artifacts/${appId}/public/data/files/${p}`);
                    try {
                        const list = await listAll(folderRef);
                        const fileDeletes = list.items.map(item => deleteObject(item));
                        await Promise.all(fileDeletes);
                    } catch(e) { console.warn("Storage folder clean issue", e); }

                    // 4. Update Local State
                    state.projects.delete(p);
                    localStorage.setItem('fp_projects', JSON.stringify(Array.from(state.projects)));

                    // 5. Switch to another project or create default
                    if(state.projects.size > 0) {
                        const next = Array.from(state.projects)[0];
                        this.switchProject(next);
                    } else {
                        this.createProject("Project-Alpha");
                    }
                    
                    showToast("Project Deleted");

                } catch(e) {
                    console.error(e);
                    alert("Delete failed: " + e.message);
                } finally {
                    toggleLoader(false);
                }
            }

            async syncProjectList() {
                // Legacy: Check storage folders too (backwards compatibility)
                try {
                    const res = await listAll(ref(state.storage, `artifacts/${appId}/public/data/files`));
                    res.prefixes.forEach(p => {
                        if(!state.projects.has(p.name)) {
                             // Adopt existing folders into new system
                             this.createProject(p.name); 
                        }
                    });
                } catch(e) {}
            }

            // --- CAMERA & CAPTURE ---
            bindEvents() {
                $('camera-input').addEventListener('change', (e) => this.handleFileSelect(e.target.files[0], false));
                $('gallery-input').addEventListener('change', (e) => this.handleFileSelect(e.target.files[0], true));
            }

            handleFileSelect(file, isGallery, type = 'photo') {
                if(!file) return;
                
                // HEIC Conversion Logic
                // Added SAFETY CHECK for file.name before accessing it
                if (file.type === "image/heic" || (file.name && file.name.toLowerCase().endsWith('.heic'))) {
                    toggleLoader(true, "Converting HEIC...");
                    heic2any({ blob: file, toType: "image/jpeg", quality: 0.9 }).then(jpgBlob => {
                        toggleLoader(false);
                        // Re-assign name property to blob for consistency - FIXED to create proper File
                        const name = (file.name ? file.name.replace(/\.[^/.]+$/, "") : "image") + ".jpg";
                        const newFile = new File([jpgBlob], name, { type: "image/jpeg" });
                        this.processBlob(newFile, true, type);
                    }).catch(e => {
                        toggleLoader(false);
                        alert("HEIC conversion failed. Please try a different photo.");
                        console.error(e);
                    });
                    return;
                }

                this.processBlob(file, isGallery, type);
            }

            processBlob(file, isGallery, type = 'photo') {
                state.pendingBlob = file;
                state.pendingId = Date.now().toString();
                state.pendingType = type; // Store type
                state.editMode = false;
                $('camera-input').value = ''; // Reset
                $('gallery-input').value = ''; // Reset

                if (isGallery) {
                    // Extract Metadata from Gallery Image
                    this.extractExif(file).then(exifData => {
                        state.tempMeta = exifData;
                        this.openCaptionModal(file, false, true); // True for "isGallery"
                    });
                } else {
                    // Live Camera - Use live sensors
                    state.tempMeta = null;
                    if(state.seriesMode) {
                        this.addToQueue(state.pendingBlob, state.pendingId);
                    } else {
                        this.openCaptionModal(file);
                    }
                }
            }
            
            extractExif(file) {
                return new Promise((resolve) => {
                    try {
                        EXIF.getData(file, function() {
                            const allTags = EXIF.getAllTags(this);
                            
                            // Parse Date
                            let timestamp = Date.now();
                            if (allTags.DateTimeOriginal) {
                                try {
                                    // Format: "2023:10:25 14:30:00" -> "2023/10/25 14:30:00"
                                    const str = allTags.DateTimeOriginal.split(' ');
                                    const dateParts = str[0].split(':');
                                    const timeParts = str[1].split(':');
                                    const date = new Date(dateParts[0], dateParts[1]-1, dateParts[2], timeParts[0], timeParts[1], timeParts[2]);
                                    if(!isNaN(date.getTime())) timestamp = date.getTime();
                                } catch(e) { console.warn("Date parse error", e); }
                            } else if (file.lastModified) {
                                 timestamp = file.lastModified;
                            }
    
                            // Parse GPS
                            let lat = null, lng = null;
                            if (allTags.GPSLatitude && allTags.GPSLongitude) {
                                // Helper to convert array [deg, min, sec] to decimal
                                const toDecimal = (gps, ref) => {
                                    if(!gps || gps.length < 3) return 0;
                                    let d = gps[0].numerator / gps[0].denominator;
                                    let m = gps[1].numerator / gps[1].denominator;
                                    let s = gps[2].numerator / gps[2].denominator;
                                    let res = d + (m/60) + (s/3600);
                                    if (ref === 'S' || ref === 'W') res = res * -1;
                                    return res;
                                };
                                lat = toDecimal(allTags.GPSLatitude, allTags.GPSLatitudeRef);
                                lng = toDecimal(allTags.GPSLongitude, allTags.GPSLongitudeRef);
                            }
                            
                            resolve({ timestamp, lat, lng });
                        });
                    } catch(e) {
                        console.error("EXIF Error", e);
                        resolve({ timestamp: Date.now(), lat: null, lng: null });
                    }
                });
            }

            toggleSeriesMode() {
                state.seriesMode = !state.seriesMode;
                const btn = $('series-btn');
                const txt = $('series-text');
                
                if(state.seriesMode) {
                    state.queue = []; // Clear old queue
                    btn.classList.remove('bg-white', 'text-slate-500', 'border-slate-200', 'hover:bg-slate-50');
                    btn.classList.add('bg-orange-50', 'text-orange-700', 'border-orange-300', 'animate-pulse');
                    txt.innerText = "Active (0)";
                } else {
                    if(state.queue.length > 0) {
                        // NEW LOGIC: Open modal instead of processing queue immediately
                        this.openBatchCaptionModal();
                    }
                    btn.classList.add('bg-white', 'text-slate-500', 'border-slate-200', 'hover:bg-slate-50');
                    btn.classList.remove('bg-orange-50', 'text-orange-700', 'border-orange-300', 'animate-pulse');
                    txt.innerText = "Series Mode";
                }
            }

            addToQueue(blob, id) {
                // If offline, save directly to IndexedDB outbox
                if(!state.online) {
                    this.offlineMgr.addToOutbox({
                        id, blob,
                        meta: this.createMeta(id, Date.now()),
                        doOverlay: $('burn-toggle').checked,
                        type: 'photo'
                    });
                    showToast("Saved to Outbox (Offline)");
                    return;
                }

                // If Online, use normal queue flow
                state.queue.push({ blob, id, timestamp: Date.now() });
                $('series-text').innerText = `Active (${state.queue.length})`;
                showToast(`Photo ${state.queue.length} Queued`);
            }
            
            // Replaced processQueue with openBatchCaptionModal logic
            
            openBatchCaptionModal() {
                const count = state.queue.length;
                if (count === 0) return;
                
                const firstItem = state.queue[0];
                let url;
                try {
                    url = URL.createObjectURL(firstItem.blob);
                } catch(e) { url = ''; }
                
                $('modal-img-preview').src = url; 
                $('cap-title').value = '';
                $('cap-desc').value = '';
                $('modal-title-text').innerText = `Batch Upload (${count} Photos)`;
                $('btn-save-upload').innerText = `Upload ${count} Photos`; 
                
                state.editMode = false;
                state.batchMode = true; 
                $('modal-caption').classList.remove('hidden');
            }

            // --- CAPTION MODAL & EDITING ---
            openCaptionModal(blobOrUrl, isEdit = false, isGallery = false) {
                let url;
                try {
                    if (typeof blobOrUrl === 'string') {
                        url = blobOrUrl;
                    } else if (blobOrUrl instanceof Blob) {
                        url = URL.createObjectURL(blobOrUrl);
                    } else {
                        throw new Error("Invalid image source");
                    }
                } catch(e) {
                    console.error("Preview Error:", e);
                    showToast("Error loading image preview");
                    return;
                }

                $('modal-img-preview').src = url;
                $('cap-title').value = isEdit ? (state.currentItem.title || '') : '';
                $('cap-desc').value = isEdit ? (state.currentItem.detailedDesc || '') : '';
                $('modal-title-text').innerText = isEdit ? "Edit Entry" : (isGallery ? "Import Details" : "New Photo Details");
                
                // Show badge if using EXIF
                const badge = $('exif-badge');
                if (isGallery && state.tempMeta && state.tempMeta.lat) {
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }

                state.editMode = isEdit;
                $('modal-caption').classList.remove('hidden');
            }

            closeCaptionModal() {
                $('modal-caption').classList.add('hidden');
                state.pendingBlob = null;
                state.tempMeta = null;
                state.batchMode = false; // Reset
                state.pendingType = 'photo'; // Reset to default
                $('btn-save-upload').innerText = "Save"; // Reset button text
            }

            createMeta(id, ts, defaultCaption = "", overrideNum = null) {
                 const title = $('cap-title').value.trim();
                 const desc = $('cap-desc').value.trim();
                 const cap = (title && desc) ? `${title} - ${desc}` : (desc || title || defaultCaption || "No Caption");
                 
                 // Get photo number
                 let thisNum;
                 if (overrideNum !== null) {
                     thisNum = overrideNum;
                 } else {
                     const existing = state.items.filter(i => i.type === 'photo');
                     const maxNum = existing.reduce((max, i) => Math.max(max, i.photoNumber || 0), 0);
                     thisNum = maxNum + 1;
                 }

                 // Use EXIF override if available, otherwise live sensors
                 let finalTs = ts;
                 let finalLat = state.location?.lat || null;
                 let finalLng = state.location?.lng || null;

                 if (state.tempMeta) {
                     finalTs = state.tempMeta.timestamp || ts;
                     // Only override location if EXIF actually had it. 
                     // If EXIF has no location (e.g. screenshot), fallback to null (don't fake it with current location)
                     if (state.tempMeta.lat && state.tempMeta.lng) {
                         finalLat = state.tempMeta.lat;
                         finalLng = state.tempMeta.lng;
                     } else {
                         finalLat = null;
                         finalLng = null;
                     }
                 }

                 return {
                     id: id,
                     projectId: state.project,
                     timestamp: finalTs,
                     dateString: formatDate(finalTs),
                     title: title,
                     detailedDesc: desc,
                     caption: cap,
                     lat: finalLat,
                     lng: finalLng,
                     heading: state.heading,
                     weather: state.weather,
                     photoNumber: thisNum
                 };
            }

            async confirmUpload() {
                if(state.editMode) {
                    this.updateEntry();
                    return;
                }

                // BATCH MODE HANDLING
                if (state.batchMode) {
                    const doOverlay = $('burn-toggle').checked;
                    const count = state.queue.length;

                    // Calculate starting photo number for sequential batch
                    const existing = state.items.filter(i => i.type === 'photo');
                    let currentMax = existing.reduce((max, i) => Math.max(max, i.photoNumber || 0), 0);

                    toggleLoader(true, `Processing ${count} items...`);
                    this.closeCaptionModal();

                    try {
                        const promises = state.queue.map((item, idx) => {
                            currentMax++; // Increment for this item
                            // Pass overrideNum to createMeta
                            const meta = this.createMeta(item.id, item.timestamp, null, currentMax);
                            // Force type photo for batch (series is photo only)
                            meta.type = 'photo';

                            if (!state.online) {
                                return this.offlineMgr.addToOutbox({
                                    id: item.id,
                                    blob: item.blob,
                                    meta: meta,
                                    doOverlay: doOverlay,
                                    type: 'photo'
                                });
                            } else {
                                return this.uploadWorkflow(item.blob, meta, doOverlay);
                            }
                        });

                        await Promise.all(promises);
                        
                        showToast(state.online ? "Batch Upload Complete" : "Batch Saved Offline");
                        state.queue = [];
                        this.switchTab('report');
                    } catch (e) {
                         alert("Batch Error: " + e.message);
                    } finally {
                        toggleLoader(false);
                    }
                    return;
                }

                // SINGLE UPLOAD HANDLING
                if(!state.pendingBlob) return;
                
                const meta = this.createMeta(state.pendingId, Date.now());
                const doOverlay = $('burn-toggle').checked;
                const blobToUpload = state.pendingBlob; // Capture blob before closing modal
                
                // Use the pending type (photo or sketch)
                meta.type = state.pendingType || 'photo';

                // OFFLINE HANDLING
                if(!state.online) {
                    toggleLoader(true, "Saving Offline...");
                    await this.offlineMgr.addToOutbox({
                        id: state.pendingId,
                        blob: blobToUpload,
                        meta: meta,
                        doOverlay: doOverlay,
                        type: meta.type
                    });
                    this.closeCaptionModal();
                    toggleLoader(false);
                    showToast("Saved to Outbox (Offline)");
                    return;
                }

                // ONLINE HANDLING
                toggleLoader(true, "Processing...");
                this.closeCaptionModal(); // This clears state.pendingBlob, but we have blobToUpload

                try {
                    await this.uploadWorkflow(blobToUpload, meta, doOverlay);
                    showToast("Upload Complete");
                    this.switchTab('report');
                } catch(e) {
                    alert("Error: " + e.message);
                } finally {
                    toggleLoader(false);
                }
            }

            async uploadWorkflow(blob, meta, doOverlay) {
                // ADDED SAFETY CHECK: Ensure blob exists
                if (!blob) {
                    console.error("Upload failed: No blob provided");
                    return;
                }

                // 1. Upload Raw - Use extension from name if possible
                let ext = 'jpg';
                if (blob.name) {
                    const parts = blob.name.split('.');
                    if (parts.length > 1) ext = parts.pop();
                }
                const rawPath = `artifacts/${appId}/public/data/files/${state.project}/raw_${meta.id}.${ext}`;
                await uploadBytes(ref(state.storage, rawPath), blob);
                meta.rawStoragePath = rawPath;

                // 2. Process Overlay (if enabled)
                let finalBlob = blob;
                if(doOverlay) {
                    finalBlob = await this.burnOverlay(blob, meta);
                }

                // 3. Upload Display Image
                const dispPath = `artifacts/${appId}/public/data/files/${state.project}/${meta.id}.jpg`;
                const snap = await uploadBytes(ref(state.storage, dispPath), finalBlob);
                const url = await getDownloadURL(snap.ref);

                // 4. Save DB Entry
                meta.url = url;
                meta.storagePath = dispPath;
                // Ensure type is set (defaults to photo if undefined, but should be passed in meta)
                if(!meta.type) meta.type = 'photo';
                
                await setDoc(doc(state.db, `artifacts/${appId}/public/data/images`, meta.id), meta);
            }

            burnOverlay(blob, meta) {
                return new Promise((resolve) => {
                    const img = new Image();
                    
                    // Fallback mechanism
                    const fallback = () => {
                        console.warn("Image processing failed, using original.");
                        resolve(blob); 
                    };

                    img.onload = () => {
                        try {
                            const c = document.createElement('canvas');
                            
                            // CALCULATE SCALED DIMENSIONS to max 2560px (Increased for quality)
                            let w = img.naturalWidth;
                            let h = img.naturalHeight;
                            const MAX_DIM = 2560;
                            
                            if (w > MAX_DIM || h > MAX_DIM) {
                                if (w > h) {
                                    h = Math.round(h * (MAX_DIM / w));
                                    w = MAX_DIM;
                                } else {
                                    w = Math.round(w * (MAX_DIM / h));
                                    h = MAX_DIM;
                                }
                            }

                            c.width = w;
                            c.height = h;
                            const ctx = c.getContext('2d');
                            
                            // Draw Image
                            ctx.fillStyle = "#fff"; ctx.fillRect(0,0,w,h);
                            ctx.drawImage(img, 0, 0, w, h);

                            // Overlay Logic
                            const fSize = Math.floor(h * 0.025);
                            const pad = fSize * 0.6;
                            const lh = fSize * 1.4;
                            
                            ctx.font = `bold ${fSize}px Inter, sans-serif`;
                            ctx.textBaseline = "top";

                            // Data Block
                            const lines = [
                                `PROJECT: ${meta.projectId}  |  PHOTO #${meta.photoNumber}`,
                                `DATE: ${meta.dateString}`,
                                `GPS: ${meta.lat ? meta.lat.toFixed(6) : '--'}, ${meta.lng ? meta.lng.toFixed(6) : '--'}`,
                                `HEADING: ${meta.heading ? Math.round(meta.heading)+'°' : '--'}`,
                                `NOTES: ${meta.caption}`
                            ];

                            // Calculate box height based on wrapping note
                            let renderLines = [];
                            const maxW = w - (pad*2);
                            
                            lines.forEach((l, i) => {
                                if(i === lines.length - 1) { // Wrap note
                                    const words = l.split(' ');
                                    let line = words[0];
                                    for(let j=1; j<words.length; j++) {
                                        if(ctx.measureText(line + " " + words[j]).width < maxW) line += " " + words[j];
                                        else { renderLines.push(line); line = words[j]; }
                                    }
                                    renderLines.push(line);
                                } else {
                                    renderLines.push(l);
                                }
                            });

                            const boxH = (renderLines.length * lh) + (pad*2);
                            
                            // Draw Box
                            ctx.fillStyle = "rgba(0,0,0,0.6)";
                            ctx.fillRect(0, h - boxH, w, boxH);

                            // Draw Text
                            ctx.fillStyle = "#ffffff";
                            let y = h - boxH + pad;
                            renderLines.forEach(l => {
                                ctx.fillText(l, pad, y);
                                y += lh;
                            });

                            c.toBlob((b) => {
                                if(b) resolve(b);
                                else fallback();
                            }, 'image/jpeg', 0.95); // High Quality
                        } catch(e) { fallback(); }
                    };
                    
                    img.onerror = fallback; // Handle unsupported formats (HEIC etc)

                    try {
                        img.src = URL.createObjectURL(blob);
                    } catch(e) {
                        fallback();
                    }
                });
            }

            // --- SKETCHING ---
            openSketch() {
                $('modal-sketch').classList.remove('hidden');
                const canvas = $('sketch-canvas');
                const wrap = $('sketch-wrapper');
                canvas.width = wrap.clientWidth;
                canvas.height = wrap.clientHeight;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = "#fff"; ctx.fillRect(0,0,canvas.width, canvas.height);
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                
                this.bgImage = null; // Clear any previous background image
                this.wbCtx = ctx;
                this.isDrawing = false;
                this.undoStack = []; // Reset Undo Stack on open

                // Event Listeners (Pointer)
                canvas.onpointerdown = (e) => { 
                    // SAVE STATE BEFORE STARTING NEW STROKE
                    this.undoStack.push(canvas.toDataURL());
                    this.isDrawing=true; 
                    ctx.beginPath(); 
                    ctx.moveTo(e.offsetX, e.offsetY); 
                };
                canvas.onpointermove = (e) => { 
                    if(!this.isDrawing) return; 
                    ctx.lineTo(e.offsetX, e.offsetY); 
                    ctx.strokeStyle = $('sketch-color').value;
                    ctx.lineWidth = $('sketch-size').value;
                    ctx.stroke(); 
                };
                canvas.onpointerup = () => this.isDrawing = false;
            }

            closeSketch() { $('modal-sketch').classList.add('hidden'); }
            
            clearSketch() { 
                const c = $('sketch-canvas'); 
                const ctx = this.wbCtx;
                
                // 1. Clear to white
                ctx.fillStyle = "#fff"; 
                ctx.fillRect(0, 0, c.width, c.height); 
                
                // 2. If we have a background image (annotating), redraw it
                if (this.bgImage) {
                    const img = this.bgImage;
                    const scale = Math.min(c.width / img.width, c.height / img.height);
                    const x = (c.width / 2) - (img.width / 2) * scale;
                    const y = (c.height / 2) - (img.height / 2) * scale;
                    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                }
            }

            undoSketch() {
                if (this.undoStack.length === 0) return;
                const previousState = this.undoStack.pop();
                const img = new Image();
                img.onload = () => {
                    const c = $('sketch-canvas');
                    this.wbCtx.clearRect(0,0, c.width, c.height);
                    this.wbCtx.drawImage(img, 0, 0);
                };
                img.src = previousState;
            }
            
            toggleEraser() {
                this.isEraser = !this.isEraser;
                const btn = $('btn-eraser');
                if (this.isEraser) {
                    this.lastColor = $('sketch-color').value;
                    // If annotating an image, "erasing" is complex without layers.
                    // For now, we will paint white, which acts as an eraser on white background
                    // but will paint white lines over a photo. This is standard simple behavior.
                    $('sketch-color').value = '#ffffff'; 
                    btn.classList.add('bg-slate-200', 'text-blue-600');
                } else {
                    $('sketch-color').value = this.lastColor; // Restore color
                    btn.classList.remove('bg-slate-200', 'text-blue-600');
                }
            }
            
            saveSketch() {
                $('sketch-canvas').toBlob((blob) => {
                    if (blob) {
                        this.closeSketch();
                        // Check if we were editing an existing item
                        const existingId = (state.editMode && state.currentItem) ? state.currentItem.id : null;
                        this.handleFileSelect(blob, false, 'sketch', existingId);
                    } else {
                        showToast("Error saving sketch");
                    }
                }, 'image/jpeg');
            }
            
            annotateImage() {
                // Check if we are in Edit Mode and have a raw file
                const current = state.currentItem;
                const useRaw = state.editMode && current && current.rawStoragePath;

                // Helper to load image into canvas
                const loadToCanvas = (src) => {
                    const canvas = $('sketch-canvas');
                    const wrap = $('sketch-wrapper');
                    canvas.width = wrap.clientWidth;
                    canvas.height = wrap.clientHeight;
                    const ctx = canvas.getContext('2d');
                    this.wbCtx = ctx;
                    this.undoStack = []; // Reset stack
                    
                    ctx.fillStyle = "#fff"; ctx.fillRect(0,0,canvas.width, canvas.height);
                    
                    const img = new Image();
                    img.crossOrigin = "Anonymous"; // CRITICAL for Firebase Storage
                    img.onload = () => {
                        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                        const x = (canvas.width / 2) - (img.width / 2) * scale;
                        const y = (canvas.height / 2) - (img.height / 2) * scale;
                        ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
                        this.bgImage = img; // Store for clear/undo logic
                        toggleLoader(false);
                    };
                    img.onerror = () => {
                        toggleLoader(false);
                        showToast("Error loading image for editing");
                    };
                    img.src = src;

                    // Re-bind events
                    this.isDrawing = false;
                    canvas.onpointerdown = (e) => { 
                        this.undoStack.push(canvas.toDataURL());
                        this.isDrawing=true; 
                        ctx.beginPath(); 
                        ctx.moveTo(e.offsetX, e.offsetY); 
                    };
                    canvas.onpointermove = (e) => { 
                        if(!this.isDrawing) return; 
                        ctx.lineTo(e.offsetX, e.offsetY); 
                        ctx.strokeStyle = $('sketch-color').value;
                        ctx.lineWidth = $('sketch-size').value;
                        ctx.stroke(); 
                    };
                    canvas.onpointerup = () => this.isDrawing = false;
                };

                this.closeCaptionModal();
                $('modal-sketch').classList.remove('hidden');
                
                // Logic to fetch correct image source
                setTimeout(async () => {
                    if (useRaw) {
                        toggleLoader(true, "Loading Raw Image...");
                        try {
                            const url = await getDownloadURL(ref(state.storage, current.rawStoragePath));
                            loadToCanvas(url);
                        } catch (e) {
                            console.error("Failed to load raw image", e);
                            toggleLoader(false);
                            // Fallback to preview image if raw fails
                            loadToCanvas($('modal-img-preview').src);
                        }
                    } else {
                        // Use the preview image (new photo or simple sketch)
                        loadToCanvas($('modal-img-preview').src);
                    }
                }, 100);
            }

            // --- NOTES ---
            openNotes() {
                $('modal-notes').classList.remove('hidden');
            }

            closeNotes() {
                $('modal-notes').classList.add('hidden');
                $('note-title').value = '';
                $('note-text').value = '';
            }

            async saveNote() {
                const title = $('note-title').value.trim();
                const text = $('note-text').value.trim();
                if(!text && !title) return showToast("Empty Note");

                const id = Date.now().toString();
                const meta = {
                    id, projectId: state.project, type: 'note',
                    title, detailedDesc: text, text,
                    timestamp: Date.now(), dateString: formatDate(Date.now()),
                    lat: state.location?.lat, lng: state.location?.lng
                };
                
                // OFFLINE NOTE
                if(!state.online) {
                    await this.offlineMgr.addToOutbox({ id, meta, type:'note' });
                    this.closeNotes();
                    showToast("Note Saved (Offline)");
                    return;
                }

                await setDoc(doc(state.db, `artifacts/${appId}/public/data/images`, id), meta);
                this.closeNotes();
                showToast("Note Saved");
                this.switchTab('report');
            }

            // --- REPORT & DATA ---
            loadData() {
                const q = query(collection(state.db, `artifacts/${appId}/public/data/images`), where("projectId", "==", state.project));
                onSnapshot(q, (snap) => {
                    state.items = [];
                    snap.forEach(d => state.items.push(d.data()));
                    state.items.sort((a,b) => b.timestamp - a.timestamp); // Newest first
                    
                    // NEW: Initialize report selection
                    // By default, assume all items are included unless explicitly excluded.
                    // This way new items are automatically included.
                    
                    this.renderFeed();
                });
            }

            renderFeed() {
                const feed = $('report-feed');
                feed.innerHTML = '';
                const term = $('search-input').value.toLowerCase();

                const filtered = state.items.filter(i => {
                    if(state.filter !== 'all' && i.type !== state.filter) return false;
                    if(term && !JSON.stringify(i).toLowerCase().includes(term)) return false;
                    return true;
                });

                if(filtered.length === 0) {
                    feed.innerHTML = `<div class="text-center text-slate-400 py-10 text-sm">No entries found.</div>`;
                    return;
                }

                filtered.forEach(item => {
                    const div = document.createElement('div');
                    div.className = "bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden flex transition hover:shadow-md relative";
                    
                    // Determine checked state based on exclusion set
                    const isChecked = !state.excludedReportItems.has(item.id);

                    // Add Checkbox HTML
                    const checkboxHtml = `
                        <div class="absolute top-2 left-2 z-20" onclick="event.stopPropagation()">
                            <input type="checkbox" class="w-5 h-5 accent-blue-600 rounded cursor-pointer shadow-sm" 
                                ${isChecked ? 'checked' : ''} 
                                onchange="window.app.toggleReportSelection('${item.id}')">
                        </div>
                    `;
                    
                    if(item.type === 'photo' || item.type === 'sketch') {
                        div.innerHTML = `
                            ${checkboxHtml}
                            <div class="w-24 h-24 bg-slate-200 relative cursor-pointer flex-none flex items-center justify-center text-slate-400" onclick="window.app.showDetail('${item.id}')">
                                <i data-lucide="${item.type === 'sketch' ? 'pen-tool' : 'image'}" class="w-8 h-8 absolute"></i>
                                <img src="${item.url}" class="w-full h-full object-cover relative z-10" onerror="this.style.display='none'">
                            </div>
                            <div class="p-3 flex-1 flex flex-col justify-between overflow-hidden">
                                <div>
                                    <div class="flex justify-between items-start">
                                        <div class="text-[10px] text-slate-400 font-mono mb-1 ml-6">${item.dateString}</div>
                                        <div class="text-[10px] font-bold ${item.type === 'sketch' ? 'text-purple-600 bg-purple-50' : 'text-blue-600 bg-blue-50'} px-1.5 py-0.5 rounded">${item.type === 'sketch' ? 'Sketch' : 'Photo #' + (item.photoNumber||'?')}</div>
                                    </div>
                                    <h4 class="text-sm font-bold text-slate-800 truncate">${item.title || 'Untitled'}</h4>
                                    <p class="text-xs text-slate-500 truncate">${item.detailedDesc || item.caption}</p>
                                </div>
                                <div class="flex justify-end gap-3 mt-2">
                                    <button onclick="window.app.editEntry('${item.id}')" class="text-xs font-bold text-slate-400 hover:text-blue-600">Edit</button>
                                    <button onclick="window.app.deleteEntry('${item.id}')" class="text-xs font-bold text-slate-400 hover:text-red-500">Delete</button>
                                </div>
                            </div>
                        `;
                    } else {
                        div.innerHTML = `
                             ${checkboxHtml}
                             <div class="w-2 bg-yellow-400 flex-none"></div>
                             <div class="p-3 flex-1">
                                <div class="flex justify-between items-start mb-1">
                                    <span class="text-[10px] text-slate-400 font-mono ml-6">${item.dateString}</span>
                                    <i data-lucide="file-text" class="w-3 h-3 text-slate-300"></i>
                                </div>
                                <h4 class="text-sm font-bold text-slate-800">${item.title || 'Note'}</h4>
                                <p class="text-xs text-slate-600 mt-1 line-clamp-2">${item.text}</p>
                                <div class="flex justify-end gap-3 mt-2 border-t border-slate-100 pt-2">
                                    <button onclick="window.app.editEntry('${item.id}')" class="text-xs font-bold text-slate-400 hover:text-blue-600">Edit</button>
                                    <button onclick="window.app.deleteEntry('${item.id}')" class="text-xs font-bold text-slate-400 hover:text-red-500">Delete</button>
                                </div>
                             </div>
                        `;
                    }
                    feed.appendChild(div);
                });
                lucide.createIcons();
            }
            
            toggleReportSelection(id) {
                if (state.excludedReportItems.has(id)) {
                    state.excludedReportItems.delete(id);
                } else {
                    state.excludedReportItems.add(id);
                }
            }

            setFilter(f) {
                state.filter = f;
                ['all','photo','sketch','note'].forEach(k => {
                    const btn = $(`filter-${k}`);
                    if(f===k) { btn.classList.remove('text-slate-500','hover:text-slate-700'); btn.classList.add('bg-white','shadow','text-slate-800'); }
                    else { btn.classList.add('text-slate-500','hover:text-slate-700'); btn.classList.remove('bg-white','shadow','text-slate-800'); }
                });
                this.renderFeed();
            }
            
            filterFeed() { this.renderFeed(); }

            async deleteEntry(id) {
                if(!confirm("Delete this entry?")) return;
                const item = state.items.find(i => i.id === id);
                toggleLoader(true, "Deleting...");
                try {
                    await deleteDoc(doc(state.db, `artifacts/${appId}/public/data/images`, id));
                    if(item.storagePath) await deleteObject(ref(state.storage, item.storagePath));
                    if(item.rawStoragePath) await deleteObject(ref(state.storage, item.rawStoragePath));
                    showToast("Deleted");
                } catch(e) { showToast("Error deleting"); }
                finally { toggleLoader(false); }
            }

            editEntry(id) {
                const item = state.items.find(i => i.id === id);
                if(!item) return;
                state.currentItem = item;
                if(item.type === 'photo' || item.type === 'sketch') {
                    this.openCaptionModal(item.url, true);
                } else {
                    // Quick alert prompt for note editing (simplification)
                    const newText = prompt("Edit Note Text:", item.text);
                    if(newText !== null) {
                         setDoc(doc(state.db, `artifacts/${appId}/public/data/images`, id), { text: newText, detailedDesc: newText }, { merge: true });
                    }
                }
            }
            
            async updateEntry() {
                const item = state.currentItem;
                const newTitle = $('cap-title').value.trim();
                const newDesc = $('cap-desc').value.trim();
                const newCap = (newTitle && newDesc) ? `${newTitle} - ${newDesc}` : newDesc;
                
                await setDoc(doc(state.db, `artifacts/${appId}/public/data/images`, item.id), {
                    title: newTitle, detailedDesc: newDesc, caption: newCap
                }, { merge: true });
                
                this.closeCaptionModal();
                showToast("Entry Updated");
            }

            // --- MAP ---
            initMap() {
                this.map = L.map('map-container').setView([39.8, -98.5], 4);
                L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                    attribution: '&copy; OpenStreetMap &copy; CARTO',
                    maxZoom: 20
                }).addTo(this.map);
                this.markers = L.layerGroup().addTo(this.map);
            }

            renderMapMarkers() {
                if(!this.map || !this.markers) return;
                this.markers.clearLayers();
                const bounds = [];
                state.items.forEach(i => {
                    if(i.lat && i.lng) {
                        let color = '#2563eb'; // blue for photo
                        if (i.type === 'note') color = '#eab308'; // yellow
                        if (i.type === 'sketch') color = '#9333ea'; // purple

                        const icon = L.divIcon({
                            className: 'custom-div-icon',
                            html: `<div style="background-color:${color}; width:12px; height:12px; border-radius:50%; border:2px solid white; box-shadow:0 2px 4px rgba(0,0,0,0.3);"></div>`,
                            iconSize: [12, 12],
                            iconAnchor: [6, 6]
                        });
                        const m = L.marker([i.lat, i.lng], { icon }).bindPopup(`<b>${i.title||'Item'}</b><br>${i.dateString}`);
                        this.markers.addLayer(m);
                        bounds.push([i.lat, i.lng]);
                    }
                });
                if(bounds.length) this.map.fitBounds(bounds, { padding: [50,50] });
            }

            centerMap() {
                if(state.location && this.map) {
                    this.map.setView([state.location.lat, state.location.lng], 16);
                    L.marker([state.location.lat, state.location.lng], {
                        icon: L.divIcon({ html: '<div class="w-4 h-4 bg-blue-500 rounded-full border-2 border-white shadow animate-pulse"></div>' })
                    }).addTo(this.map);
                } else {
                    showToast("Waiting for GPS...");
                }
            }

            // --- DETAIL VIEW ---
            showDetail(id) {
                const item = state.items.find(i => i.id === id);
                if(!item) return;
                $('det-img').src = item.url;
                $('det-project').innerText = item.projectId;
                $('det-id').innerText = item.id;
                $('det-caption').innerText = item.caption;
                $('det-date').innerText = item.dateString;
                
                const gpsEl = $('det-gps');
                if(item.lat) {
                    gpsEl.innerText = `${item.lat.toFixed(6)}, ${item.lng.toFixed(6)}`;
                    gpsEl.href = `https://www.google.com/maps?q=${item.lat},${item.lng}`;
                } else {
                    gpsEl.innerText = "No Data"; gpsEl.removeAttribute('href');
                }
                
                $('det-dl-btn').onclick = () => this.downloadFile(item.url, `${item.projectId}_${item.id}.jpg`);
                
                const rawBtn = $('det-raw-btn');
                if(item.rawStoragePath) {
                    rawBtn.classList.remove('hidden');
                    rawBtn.onclick = async () => {
                         const url = await getDownloadURL(ref(state.storage, item.rawStoragePath));
                         this.downloadFile(url, `${item.projectId}_${item.id}_RAW.jpg`);
                    };
                } else {
                    rawBtn.classList.add('hidden');
                }

                $('detail-modal').classList.remove('hidden');
            }

            async downloadFile(url, name) {
                try {
                    const r = await fetch(url);
                    const b = await r.blob();
                    const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = name;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a);
                } catch(e) { alert("Download failed"); }
            }

            // --- FILES ---
            async refreshFiles() { this.loadFiles(state.path); }
            async loadFiles(path) {
                const grid = $('file-grid');
                $('browser-path').innerText = path;
                grid.innerHTML = '<div class="col-span-full text-center text-xs text-slate-400">Loading...</div>';
                
                try {
                    const res = await listAll(ref(state.storage, path));
                    grid.innerHTML = '';
                    
                    // Folders
                    res.prefixes.forEach(p => {
                        const el = document.createElement('div');
                        el.className = "bg-yellow-50 border border-yellow-200 rounded-lg p-3 flex flex-col items-center justify-center cursor-pointer hover:bg-yellow-100 aspect-square";
                        el.onclick = () => this.loadFiles(p.fullPath);
                        el.innerHTML = `<i data-lucide="folder" class="w-8 h-8 text-yellow-500 mb-2"></i><span class="text-[10px] font-bold text-yellow-800 truncate w-full text-center">${p.name}</span>`;
                        grid.appendChild(el);
                    });

                    // Files
                    for(const item of res.items) {
                         const url = await getDownloadURL(item);
                         const el = document.createElement('div');
                         el.className = "bg-white border border-slate-200 rounded-lg overflow-hidden relative group aspect-square";
                         el.innerHTML = `
                            <img src="${url}" class="w-full h-full object-cover">
                            <a href="${url}" target="_blank" class="absolute inset-0"></a>
                            <div class="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-[9px] p-1 truncate">${item.name}</div>
                         `;
                         grid.appendChild(el);
                    }
                    if(!res.prefixes.length && !res.items.length) grid.innerHTML = '<div class="col-span-full text-center text-xs text-slate-300 py-10">Empty Folder</div>';
                    lucide.createIcons();
                    state.path = path;
                } catch(e) { grid.innerHTML = `<div class="text-red-500 text-xs">Error loading files</div>`; }
            }
            
            fileBrowserUp() {
                const parts = state.path.split('/');
                if(parts.length > 1) { parts.pop(); this.loadFiles(parts.join('/')); }
            }

            // --- EXPORTS ---
            async genPDF() {
                // Filter items based on checkbox state (excluded list)
                const exportItems = state.items.filter(i => !state.excludedReportItems.has(i.id));
                
                if(exportItems.length === 0) return showToast("No items selected for report");

                toggleLoader(true, "Generating PDF...");
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                let y = 20;
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                
                // Title Page
                doc.setFontSize(22); 
                doc.text("Field Inspection Report", pageWidth/2, 40, {align:'center'});
                
                doc.setFontSize(14); 
                doc.text(`Project: ${state.project}`, pageWidth/2, 55, {align:'center'});
                doc.text(`Generated: ${new Date().toLocaleString()}`, pageWidth/2, 65, {align:'center'});
                
                const addFooter = (pageNum) => {
                    doc.setFontSize(8);
                    doc.text(`Page ${pageNum}`, pageWidth - 20, doc.internal.pageSize.getHeight() - 10);
                };
                let pageNum = 1;
                addFooter(pageNum);

                // Helper for Images (Photos & Sketches)
                const addImagesToPDF = async (sectionTitle, items) => {
                    if(items.length === 0) return;
                    
                    doc.addPage(); pageNum++; addFooter(pageNum); y = 20;
                    doc.setFontSize(16); doc.text(sectionTitle, 15, y); y += 15;

                    for(let i=0; i<items.length; i++) {
                        const p = items[i];
                        try {
                            const imgData = await this.urlToBase64(p.url);
                            const imgProps = doc.getImageProperties(imgData);
                            const ratio = imgProps.height / imgProps.width;
                            const maxW = 170; 
                            const maxH = 100; 
                            
                            let displayW = maxW;
                            let displayH = displayW * ratio;
                            if (displayH > maxH) { displayH = maxH; displayW = displayH / ratio; }

                            doc.setFontSize(9);
                            const caption = p.caption || p.detailedDesc || "No caption";
                            const splitText = doc.splitTextToSize(caption, 170);
                            const textBlockH = 15 + (splitText.length * 5); 
                            const totalBlockH = displayH + textBlockH + 10; 

                            if (y + totalBlockH > pageHeight - 20) { 
                                doc.addPage(); pageNum++; addFooter(pageNum); y = 20; 
                            }
                            
                            const x = 20 + (maxW - displayW) / 2;
                            doc.addImage(imgData, 'JPEG', x, y, displayW, displayH);
                            doc.setDrawColor(200); doc.rect(x, y, displayW, displayH);
                            y += displayH + 5; 
                            
                            doc.setFontSize(10); doc.setFont("helvetica", "bold");
                            // Number sketches sequentially in the report using 'i+1' for this section
                            const label = p.type === 'sketch' ? `Sketch ${i+1}` : `Photo #${p.photoNumber || (i+1)}`;
                            doc.text(label, 20, y);
                            
                            doc.setFont("helvetica", "normal");
                            const dateStr = p.dateString || new Date(p.timestamp).toLocaleString();
                            doc.text(dateStr, 190, y, {align:'right'});
                            y += 5;
                            doc.setFontSize(9);
                            doc.text(splitText, 20, y);
                            y += (splitText.length * 5) + 10;
                        } catch(e) { console.error("PDF Image Error", e); }
                    }
                };

                // 1. Field Notes (First)
                const notes = exportItems.filter(i => i.type === 'note');
                if(notes.length > 0) {
                    doc.addPage(); pageNum++; addFooter(pageNum); y = 20;
                    doc.setFontSize(16); doc.text("Field Notes", 15, y); y += 15;
                    notes.forEach((n, idx) => {
                        if(y + 40 > pageHeight) { doc.addPage(); pageNum++; addFooter(pageNum); y = 20; }
                        doc.setDrawColor(220); doc.setFillColor(248, 250, 252);
                        doc.roundedRect(15, y, 180, 0, 2, 2); 
                        const startY = y; y += 5;
                        doc.setFontSize(11); doc.setFont("helvetica", "bold"); doc.text(n.title || "Note", 20, y);
                        doc.setFontSize(9); doc.setFont("helvetica", "normal"); doc.text(n.dateString, 185, y, {align:'right'});
                        y += 7;
                        const desc = n.text || n.detailedDesc || "";
                        const splitDesc = doc.splitTextToSize(desc, 170);
                        doc.text(splitDesc, 20, y);
                        y += (splitDesc.length * 5) + 10;
                        const height = y - startY - 5;
                        doc.rect(15, startY, 180, height);
                        y += 5;
                    });
                }

                // 2. Photo Log (Second)
                await addImagesToPDF("Photo Log", exportItems.filter(i => i.type === 'photo'));

                // 3. Sketch Log (Third)
                await addImagesToPDF("Sketch Log", exportItems.filter(i => i.type === 'sketch'));
                
                doc.save(`${state.project}_Report.pdf`);
                toggleLoader(false);
            }

            async genCSV() {
                const exportItems = state.items.filter(i => !state.excludedReportItems.has(i.id));
                if(exportItems.length === 0) return showToast("No items selected");

                const rows = [["ID","Type","Date","Title","Description","Lat","Lng","URL"]];
                exportItems.forEach(i => {
                    rows.push([
                        i.id, i.type, i.dateString, i.title||'', (i.detailedDesc||i.text||'').replace(/,/g, ';'), 
                        i.lat||'', i.lng||'', i.url||''
                    ]);
                });
                const csv = rows.map(r => r.join(",")).join("\n");
                const b = new Blob([csv], {type:'text/csv'});
                const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `${state.project}.csv`;
                a.click();
            }

            async genZip() { this._zipHelper(state.items.filter(i => i.type==='photo' && !state.excludedReportItems.has(i.id)), 'Photos'); }
            async genRawZip() { this._zipHelper(state.items.filter(i => i.type==='photo' && i.rawStoragePath && !state.excludedReportItems.has(i.id)), 'Raw', true); }

            async _zipHelper(list, name, isRaw=false) {
                if(!list.length) return showToast("No items selected");
                toggleLoader(true, "Zipping...");
                const zip = new JSZip();
                for(const i of list) {
                    try {
                        const u = isRaw ? await getDownloadURL(ref(state.storage, i.rawStoragePath)) : i.url;
                        const b = await (await fetch(u)).blob();
                        zip.file(`${i.projectId}_${i.id}${isRaw?'_RAW':''}.jpg`, b);
                    } catch(e){}
                }
                const c = await zip.generateAsync({type:"blob"});
                const a = document.createElement('a'); a.href = URL.createObjectURL(c); a.download = `${state.project}_${name}.zip`;
                a.click();
                toggleLoader(false);
            }

            urlToBase64(url) {
                return new Promise((r, j) => {
                    const img = new Image(); img.crossOrigin='Anonymous';
                    img.onload = () => {
                        const c = document.createElement('canvas'); c.width=img.naturalWidth; c.height=img.naturalHeight;
                        c.getContext('2d').drawImage(img,0,0); r(c.toDataURL('image/jpeg'));
                    };
                    img.onerror = j; img.src = url;
                });
            }
        }

        // Initialize
        window.onload = () => { window.app = new FieldApp(); };
    </script>
</body>
</html>
